import java.io.*;
import java.net.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;

public class ServidorJogo {
    private static final int PORT = 12345;
    private static final int MAX_THREADS = 10; //
    private static final int TEMPO_LOGIN_SEC = 30; // Tempo para aceitar jogadores
    private static final int TEMPO_JOGO_SEC = 60;  // Tempo limite do jogo

    // Estado Global do Jogo
    private static int NUMERO_SECRETO;
    private static int MIN_VAL;
    private static int MAX_VAL;
    private static volatile boolean aceitarNovosJogadores = true;
    private static volatile boolean jogoComecou = false;
    private static volatile boolean jogoTerminou = false;
    private static volatile String nomeVencedor = null;

    // Lista de clientes para broadcasts (opcional, mas útil para fechar sockets no fim)
    private static final List<ClientHandler> clientesConectados = Collections.synchronizedList(new ArrayList<>());
    private static final ExecutorService pool = Executors.newFixedThreadPool(MAX_THREADS); //

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        try {
            // 1. Configuração Inicial
            System.out.println("Main: Por favor, introduza o valor minimo a ser indicado aos utilizadores"); //
            MIN_VAL = sc.nextInt();
            System.out.println("Main: Por favor, introduza o valor máximo a ser indicado aos utilizadores");
            MAX_VAL = sc.nextInt();

            // Gerar número aleatório no intervalo
            NUMERO_SECRETO = new Random().nextInt((MAX_VAL - MIN_VAL) + 1) + MIN_VAL;

            // Reset logins
            GestorUtilizadores.resetLogins(); //

            ServerSocket serverSocket = new ServerSocket(PORT);
            System.out.println("Main: à espera de ligações"); //

            // Thread para contar o tempo de Login
            new Thread(() -> {
                try {
                    Thread.sleep(TEMPO_LOGIN_SEC * 1000);
                    aceitarNovosJogadores = false;
                    System.out.println("Main: Acabou o tempo para entrar no jogo"); //

                    // Iniciar o jogo para quem está conectado
                    iniciarJogo();

                    // Fechar o socket do servidor para não aceitar mais conexões no accept()
                    serverSocket.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();

            // Loop de aceitação de clientes
            while (aceitarNovosJogadores) {
                try {
                    Socket clientSocket = serverSocket.accept();
                    if (!aceitarNovosJogadores) { // Verificação dupla caso o socket feche
                        clientSocket.close();
                        break;
                    }
                    System.out.println("Main: Nova ligação"); //

                    ClientHandler handler = new ClientHandler(clientSocket);
                    clientesConectados.add(handler);
                    pool.execute(handler); // Executar na pool
                } catch (SocketException e) {
                    // Ocorre quando fechamos o socket ao fim do tempo
                }
            }

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            pool.shutdown();
        }
    }

    private static void iniciarJogo() {
        jogoComecou = true;
        // Notifica as threads que estão em espera (wait)
        synchronized (clientesConectados) {
            clientesConectados.notifyAll();
        }

        // Timer do Jogo
        new Thread(() -> {
            try {
                Thread.sleep(TEMPO_JOGO_SEC * 1000);
                if (!jogoTerminou) {
                    jogoTerminou = true; //
                    System.out.println("Main: Tempo de jogo esgotado sem vencedor.");
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }

    // --- Lógica do Cliente (Thread) ---
    private static class ClientHandler implements Runnable {
        private Socket socket;
        private PrintWriter out;
        private BufferedReader in;
        private String username;

        public ClientHandler(Socket socket) {
            this.socket = socket;
        }

        @Override
        public void run() {
            long threadId = Thread.currentThread().getId();
            try {
                out = new PrintWriter(socket.getOutputStream(), true);
                in = new BufferedReader(new InputStreamReader(socket.getInputStream()));

                // --- FASE 1: LOGIN (Max 3 tentativas) ---
                int tentativas = 3;
                boolean logado = false;

                while (tentativas > 0 && !logado && aceitarNovosJogadores) {
                    // Protocolo: Pedir User/Pass. O cliente envia "USER" e depois "PASS"
                    System.out.println("Thread servidor " + threadId + ": À espera do username do novo cliente"); //
                    String user = in.readLine();
                    if (user == null) return;

                    System.out.println("Thread servidor " + threadId + ": À espera da password do novo cliente"); //
                    String pass = in.readLine();
                    if (pass == null) return;

                    if (GestorUtilizadores.autenticar(user, pass)) { //
                        logado = true;
                        this.username = user;
                        out.println("LOGIN_SUCCESS"); //
                        System.out.println("Thread servidor " + threadId + ": O utilizador " + user + " efetuou Login com sucesso."); //
                    } else {
                        tentativas--;
                        System.out.println("Thread servidor " + threadId + ": Login falhado para o utilizador " + user); //
                        if (tentativas > 0) {
                            out.println("LOGIN_WRONG:" + tentativas); //
                        } else {
                            out.println("LOGIN_MAX_ATTEMPTS"); //
                            socket.close(); //
                            return;
                        }
                    }
                }

                if (!logado) return; // Se saiu do loop sem logar (tempo acabou ou socket fechou)

                // --- FASE 2: ESPERA PELO INÍCIO DO JOGO ---
                out.println("WAIT_START"); // Avisa cliente para esperar

                synchronized (clientesConectados) {
                    while (!jogoComecou) {
                        try {
                            clientesConectados.wait(); // Bloqueia até o timer de login acabar
                        } catch (InterruptedException e) {
                            return;
                        }
                    }
                }

                // Envia intervalo para o cliente
                out.println("GAME_START:" + MIN_VAL + ":" + MAX_VAL);
                System.out.println("Thread servidor " + threadId + ": O utilizador " + username + " foi informado de que o jogo vai começar"); //

                // --- FASE 3: JOGO ---
                String inputLine;
                while ((inputLine = in.readLine()) != null) {
                    // Verifica se o jogo já acabou antes de processar
                    if (jogoTerminou) {
                        if (nomeVencedor != null) {
                            if (nomeVencedor.equals(this.username)) {
                                out.println("ALREADY_WON_BY_YOU");
                            } else {
                                out.println("GAME_OVER_WINNER:" + nomeVencedor + ":" + NUMERO_SECRETO); //
                                System.out.println("Thread servidor " + threadId + ": O utilizador " + username + " foi informado de que o jogador " + nomeVencedor + " já tinha acertado no número (" + NUMERO_SECRETO + ")"); //
                            }
                        } else {
                            out.println("GAME_OVER_TIMEOUT"); //
                        }
                        break;
                    }

                    // Verifica desistência
                    if (inputLine.equalsIgnoreCase("Desisto")) {
                        System.out.println("Thread servidor " + threadId + ": O utilizador " + username + " desistiu.");
                        break; // Sai do loop e fecha thread
                    }

                    try {
                        int palpite = Integer.parseInt(inputLine);
                        System.out.println("Thread servidor " + threadId + ": O utilizador " + username + " enviou " + palpite); //

                        if (palpite == NUMERO_SECRETO) {
                            // Vitória
                            jogoTerminou = true;
                            nomeVencedor = username;
                            out.println("WIN");
                            System.out.println("Thread servidor " + threadId + ": O utilizador " + username + " acertou no número"); //
                            System.out.println("Main: O utilizador " + username + " ganhou"); //
                            break;
                        } else if (palpite < NUMERO_SECRETO) {
                            out.println("HINT_HIGHER"); //
                            System.out.println("Thread servidor " + threadId + ": O utilizador " + username + " enviou o número " + palpite + " que é inferior ao número a adivinhar (" + NUMERO_SECRETO + ")"); //
                        } else {
                            out.println("HINT_LOWER"); //
                            System.out.println("Thread servidor " + threadId + ": O utilizador " + username + " enviou o número " + palpite + " que é superior ao número a adivinhar (" + NUMERO_SECRETO + ")"); //
                        }

                    } catch (NumberFormatException e) {
                        out.println("ERROR: Numero invalido");
                    }
                }

                System.out.println("Thread servidor " + threadId + ": terminou para o utilizador " + username); //

            } catch (IOException e) {
                // Cliente desconectado
            } finally {
                try { socket.close(); } catch (IOException e) {}
            }
        }
    }
}
